<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS masarService</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
/*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     body { margin-right: 10% }
/*]]>*/</style>
</head>

<body>

<div class="head">
<h1>EPICS masarService</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount" id="L50">EPICS v4 Working Group, Working Draft,
2012.01.20</h2>
<dl>
  <dt>Previous version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/masarService_20120112.html">masarService_20120116.html</a></dd>
  <dt>Editors:</dt>
    <dd>Guobao Shen, BNL</dd>
    <dd>Marty Kraimer, BNL</dd>
</dl>
<hr />
</div>
<hr />

<h2 class="nocount" id="L71">Abstract</h2>
<hr />

<p>masarService is a service that creates, saves, and retrieves snapshots of
data from a set of V3 channels.</p>

<p>It is one of a set of related products:</p>
<dl>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/masarService/raw-file/tip/documentation/masarService.html">pvData</a></dt>
    <dd>pvData (Process Variable Daata) defines and implements an efficent way
      to store, access, and transmit memory resident structured data</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvAccessCPP/raw-file/tip/documentation/pvAccessCPP.html">pvAccess</a></dt>
    <dd>pvAccess is network support for transmitting pvData.</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvIOCCPP/raw-file/tip/documentation/pvIOCCPP.html">pvIOC</a></dt>
    <dd>A pvIOC is a network accessable smart real time database. The database
      consists of memory resident records. Each record has a name that is
      uniquie within the local area network and contains a top level pvData
      structure. Each field of a record can optionally have support code
      attached to it. The support is called when a request is made to process
      the record. The support code is what makes the record "smart". A pvAccess
      server is provided so that the records can be accesed via the network.
    </dd>
</dl>

<p>Each of the products has a Java and a C++ implementation.</p>

<p>The products are all part of the <a
href="http://epics-pvdata.sourceforge.net/">V4</a> implementation of <a
href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
Control System.</a></p>
<hr />

<h2 class="nocount" id="L109">Status of this Document</h2>
<hr />

<p>This is the C++ and python implementation of masarService. It is currently
under development.</p>

<p><b>Known Problem</b> If ClientFactory.stop is called in ezchannelRPC.cpp
then python will crash when python terminates.</p>
<hr />

<h2 class="nocount" style="text-align:center" id="L121">Table of Contents</h2>
<hr />

<p>x</p>

<div class="toc">
<ul>
  <li><a href="#L50">EPICS v4 Working Group, Working Draft, 2012.01.20</a></li>
  <li><a href="#L71">Abstract</a></li>
  <li><a href="#L109">Status of this Document</a></li>
  <li><a href="#L121">Table of Contents</a></li>
  <li><a href="#L129">Preface</a></li>
  <li><a href="#L149">Introduction</a></li>
  <li><a href="#L157">Building</a></li>
  <li><a href="#L191">Testing</a>
    <ul>
      <li><a href="#L207">gatherV3ScalarDataPut</a></li>
      <li><a href="#L213">gatherV3ScalarDataExample</a></li>
      <li><a href="#L219">gatherV3ScalarDataTest</a></li>
      <li><a href="#L229">masarServiceRun</a></li>
      <li><a href="#L241">testezchannelRPC</a></li>
      <li><a href="#L249">testchannelRPC.py</a></li>
    </ul>
  </li>
  <li><a href="#L261">C++ Client</a>
    <ul>
      <li><a href="#L267">ezchannelRPC</a></li>
      <li><a href="#L323">gatherV3ScalarData</a></li>
    </ul>
  </li>
  <li><a href="#L458">Python Client</a>
    <ul>
      <li><a href="#L464">channelRPC</a></li>
      <li><a href="#L472">ntnameValue</a></li>
      <li><a href="#L482">nttable</a></li>
      <li><a href="#L490">alarm</a></li>
      <li><a href="#L498">timeStamp</a></li>
    </ul>
  </li>
  <li><a href="#L510">C++ Server</a>
    <ul>
      <li><a href="#L516">service</a></li>
      <li><a href="#L530">dsl.h - Data Source Layer</a></li>
      <li><a href="#L538">dslPy</a></li>
    </ul>
  </li>
  <li><a href="#L544">Python Server</a></li>
  <li><a href="#L552">Python support for Standard Structures</a></li>
  <li><a href="#L642">Python support for Normative Types</a></li>
  <li><a href="#L657">Python support for pvAccess</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="L129">Preface</h2>
<hr />

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>This is the overview for masarService, which is a service that defines,
creates, and retrieves snapshots of data from a set of V3 channels.</p>

<p>An arbitrary number of snapshot definitions can be created and saved in a
relational database. I snapshot definition defines a set of V3 channels from
which to collect data.</p>

<p>For each shapshot definition an arbitrary set of snapshots can be obtained
and saved in the relational database.</p>

<p>A client can retrive any saved snapshot.</p>

<p>This service uses pvData/pvAccess for all communication between a client and
the masarSevice.</p>
<hr />

<h2 style="text-align: center" id="L149">Introduction</h2>
<hr />

<p>x</p>
<hr />

<h2 style="text-align: center" id="L157">Building</h2>
<hr />

<p>For now the only way to obtain the masarService is from the sourceforge
mercurial repository. For example:</p>
<pre>hg clone http://epics-pvdata.hg.sourceforge.net/hgroot/epics-pvdata/masarService</pre>

<p>or</p>
<pre>hg clone ssh://&lt;your-sourceforge-userid&gt;@epics-pvdata.hg.sourceforge.net/hgroot/epics-pvdata/masarSevice</pre>

<p>After cloning the masarService a RELEASE.local file for C++ must be created
and the masarService must be built.</p>
<pre>cd masarSevice/cpp/configure
create configure/RELEASE.local
make</pre>

<p>The RELEASE.local must define several variables. An example is:</p>
<pre>PYTHON=python2.7
PYTHON_BASE=/usr

REPBASE=/home/mrk/hg
PVDATA=${REPBASE}/pvDataCPP
PVACCESS=${REPBASE}/pvAccessCPP
PVIOC=${REPBASE}/pvIOCCPP
NT=${REPBASE}/alphaCPP/normativeTypes

EPICS_BASE=/home/install/epics/base</pre>

<p>Note that python, pvData, pvAccess, pvIOC, and normative types must all be
installed and built in order to build the masarService.</p>

<p>Once the masarService is build the tests described in the next section can
be run to check that everything has built properly.</p>

<p>The python code requires that that the extension modules have links to a
shared library. To create these links do the following:</p>
<pre>cd masarService/cpp/src/python
python generateSOLinks.py</pre>

<p>Also PYTHONPATH must have definitions similar to the following:</p>
<pre>export PYTHONPATH=/home/install/python2.7/lib/python2.7/site-packages/
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/cpp/src/python
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/python/src/server
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/python/src/client
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/python</pre>
<hr />

<h2 style="text-align: center" id="L191">Testing</h2>
<hr />

<p>masarService/python/test has some python tests. This section describes C++
tests.</p>

<p>The gatherV3ScalarData test require the the V3 IOC provided with this
project is running. It is stated via:</p>
<pre>
$cd masarService/test/v3IOC
$softIoc st.cmd
</pre>
<p>
An assumption here is the $EPICS_BASE/bin/$EPICS_HOST_ARCH is in the $PATH already.
Otherwise, a full path should be given for softIoc, which is included in recent EPICS
V3 Base release.
</p>
<p>The test database has 1000 records named masarExample0000, ...,
masarExample0999. The first four records have types longout, stringout, bo, and
mbbo. The other records are all ao records.</p>

<p>Each of the C++ example and test programs can be executed from the installed
bin directory. For example on my linux machine:</p>
<pre>cd masarService/cpp/bin/linux-x86
 ./gatherV3ScalarDataPut</pre>

<h3 id="L207">gatherV3ScalarDataPut</h3>

<p>This writes values into the first ten records of the test V3 IOC. A sample
run is:</p>
<pre>mrk&gt; pwd
/home/mrk/hg/masarService/cpp/bin/linux-x86
mrk&gt; ./gatherV3ScalarDataPut
nttable
structure NTTable
    structure timeStamp
        long secondsPastEpoch 0
        int nanoSeconds 0
        int userTag 0
    structure alarm
        int severity 0
        int status 0
        string message 
    string[] label [doubleValue,intValue,stringValue,secondsPastEpoch,nanoSeconds,timeStampTag,alarmSeverity,alarmStatus,alarmMessage,dbrType,isConnected,channelName]
    double[] doubleValue [10,0,0,0,1.9,1,1,1,1,1]
    int[] intValue [10,0,0,0,0,0,0,0,0,0]
    string[] stringValue [10,string value,zero,one,1.900000e+00,1.000000e+00,1.000000e+00,1.000000e+00,1.000000e+00,1.000000e+00]
    long[] secondsPastEpoch [-631152000,-631152000,-631152000,-631152000,-631152000,-631152000,-631152000,-631152000,-631152000,-631152000]
    int[] nanoSeconds [0,0,0,0,0,0,0,0,0,0]
    int[] timeStampTag [0,0,0,0,0,0,0,0,0,0]
    int[] alarmSeverity [3,3,3,3,3,3,3,3,3,3]
    int[] alarmStatus [17,17,17,17,17,17,17,17,17,17]
    string[] alarmMessage [UDF,UDF,UDF,UDF,UDF,UDF,UDF,UDF,UDF,UDF]
    int[] dbrType [5,0,3,3,6,6,6,6,6,6]
    boolean[] isConnected [true,true,true,true,true,true,true,true,true,true]
    string[] channelName [masarExample0000,masarExample0001,masarExample0002,masarExample0003,masarExample0004,masarExample0005,masarExample0006,masarExample0007,masarExample0008,masarExample0009]</pre>

<h3 id="L213">gatherV3ScalarDataExample</h3>

<p>This tests gets a set of V3 channels. It produces:</p>
<pre>mrk&gt; ./gatherV3ScalarDataExample
values: double[] doubleValue [10,0,0,0,1.9,1,1,1,1,1]
values: double[] doubleValue [10,0,0,0,1.9,1,1,1,1,1]
GatherV3ScalarData::~GatherV3ScalarData()</pre>

<h3 id="L219">gatherV3ScalarDataTest</h3>

<p>This tests gets a large set of V3 channels. This test also requires the test
V3 database of the gather service. It must be started before running this
test.</p>

<p>This test prints nothing if it is successfull. To run just execute:</p>
<pre>mrk&gt; pwd
/home/mrk/hg/masarService/cpp
mrk&gt; bin/linux-x86/gatherV3ScalarDataExample </pre>

<p>Thus test can also be run with a debug option. In this case it only gets
data from the first 6 channels but displays lots of output.</p>

<h3 id="L229">masarServiceRun</h3>

<p>This is a dummy server. it just accepts a channelRPC request and always
returns a PVStructure that is an NTTable.</p>

<p>To start the server:</p>
<pre>cd masarService/cpp/bin/&lt;arch&gt;
 ./masarServiceRun</pre>

<p>To stop the server type "exit".</p>

<p>The server must be run in order to run the next two tests.</p>

<h3 id="L241">testezchannelRPC</h3>

<p>This is a C++ client that makes a channelRPC request to the dummy server.</p>

<p>To run this test:</p>
<pre>cd masarService/cpp/bin/&lt;arch&gt;
 ./testezchannelRPC</pre>

<h3 id="L249">testchannelRPC.py</h3>

<p>This is a python client program that makes a channelRPC request to the dummy
server.</p>

<p>To run this test:</p>
<pre>cd masarService/python/test
python testchannelRPC.py</pre>

<p></p>
<hr />

<h2 style="text-align: center" id="L261">C++ Client</h2>
<hr />

<p>This section describes two client facilities that will both be moved tp
EZPVA ( Easy PVAccess) when it exists. For now they are here because the
masarService needs them.</p>

<h3 id="L267">ezchannelRPC</h3>

<p>EZChannelRPC is class that provides an easy way to make a channelRPC
request. The client provides a PVStructure that is the argument for the
channelRPC request and receives a PVStructure that holds the result. The class
definition is:</p>
<pre>class EZChannelRPC {
public:
    EZChannelRPC(String channelName);
    EZChannelRPC(String channelName,PVStructure::shared_pointer pvRequest);
    void destroy();
    bool connect(double timeOut);
    void issueConnect();
    bool waitConnect(double timeOut);
    PVStructure::shared_pointer request(
        PVStructure::shared_pointer const &amp; pvArgument,bool lastRequest);
    void  issueRequest(
        PVStructure::shared_pointer const &amp; pvArgument,bool lastRequest);
    PVStructure::shared_pointer waitRequest();
    String getMessage();
};</pre>

<p>where</p>
<dl>
  <dt>EZChannelRPC</dt>
    <dd>The constructor. channelName is the name of the channelRPC server.
      pvRequest is a request structure to pass to the server. If pvRequest is
      not given a default structure will be created.</dd>
  <dt>destroy</dt>
    <dd>This will clean up all resources used by the channelRPC </dd>
  <dt>connect</dt>
    <dd>Connect to the server. The method blocks until the connection is made
      or a timeout occurs. It is the same as calling issueConnect and then
      waitConnect. returns (false,true) if (not connected, is connected). If
      false then connect must be reissued. </dd>
  <dt>issueConnect</dt>
    <dd>Issue a connect request and return immediately. waitConnect must be
      called to complete the request. </dd>
  <dt>waitConnect</dt>
    <dd>Wait for the connect request to complete. timeout is the timeout in
      seconds to wait. returns (false,true) If (not connected, is connected).
      If false then connect must be reissued. </dd>
  <dt>request</dt>
    <dd>Make a channelRPC request. pvArgument is the argument to pass to the
      server. If lastRequest is true an automatic destroy is made. returns the
      result. If the result is null then getMessage can be called to get the
      reason. </dd>
  <dt>issueRequest</dt>
    <dd>Issue a channelRPC request and return immediately. pvArgument is the
      argument to pass to the server. If lastRequest is true an automatic
      destroy is made. waitRequest must be called to complete the request. </dd>
  <dt>waitRequest</dt>
    <dd>Wait for the request to complete. returns the result. If the result is
      null then getMessage can be called to get the reason. </dd>
  <dt>getMessage</dt>
    <dd>Get the reason why a connect or request failed.</dd>
</dl>

<p>masarService/cpp/test/testezchannelRPC/testezchannelRPC.cpp provides an
example of how to use this class.</p>

<h3 id="L323">gatherV3ScalarData</h3>

<p>Gather an array of V3 scalar double values. The complete set of data is
presented as an NTTable. The NTTable has the optional fields alarm and
timeStamp. The class definition is:</p>
<pre>class GatherV3ScalarData {
public:
    GatherV3ScalarData(String channelNames[],int numberChannels);
    bool connect(double timeOut);
    void disconnect();
    bool get();
    bool put();
    String getMessage();
    PVStructure::shared_pointer getNTTable();
    PVIntArray *getIntArrray();
    PVDoubleArray *getDoubleValue();
    PVStringArray *getStringValue();
    PVLongArray *getSecondsPastEpoch();
    PVIntArray *getNanoSeconds();
    PVIntArray *getTimeStampTag();
    PVIntArray *getAlarmSeverity();
    PVIntArray *getAlarmStatus();
    PVStringArray *getAlarmMessage();
    PVIntArray *getDBRType();
    PVBooleanArray *getIsConnected();
    PVStringArray  *getChannelName();
};</pre>

<p>where</p>
<dl>
  <dt>GatherV3ScalarData</dt>
    <dd>The constructor. channelNames is the array of channelNames to gather.
      numberChannels is the number of channels to gather. </dd>
  <dt>connect</dt>
    <dd>Connect to V3 channels. This call blocks until all channels are
      connected or until timeout. timeout is the number of seconds to wait for
      connections. The return value is true if all channels are connected and
      false otherwise. If false then all channels are cleared and connect must
      be reissued. </dd>
  <dt>disconnect</dt>
    <dd>Disconnect from the V3 channels.</dd>
  <dt>get</dt>
    <dd>Get the current values of the V3 channels.</dd>
    <dd><b>NOTE:</b> get MUST be called by the same thread that calls
    connect.</dd>
    <dd>The return value is true if all gets were successful. If the return
      value is false then getMessage can be called to get the reason. If any
      channel is disconnected false is returned. </dd>
  <dt>getMessage</dt>
    <dd>Get the reason why a connect or get failed.</dd>
  <dt>getNTTable</dt>
    <dd>The data is saved as an NTTable with alarm and timeStamp. Get it.</dd>
  <dt>getIntValue</dt>
    <dd>Get the array of values for each V3 channel as int values. If the V3
      datatype for the channel is not an integer type the value will always be
      0.</dd>
  <dt>getDoubleValue</dt>
    <dd>Get the array of values for each V3 channel as double values. If the V3
      datatype for the channel is not a numeric type the double value will
      always be 0.</dd>
  <dt>getStringValue</dt>
    <dd>Get the arrray of values for each V3 channel as string values.</dd>
  <dt>getSecondsPastEpoch</dt>
    <dd>Get the array of secondsPastEpoch for each V3 channel. The epoch is
      midnight 1970 UTC time. </dd>
  <dt>getNanoSeconds</dt>
    <dd>Get the array of nanoSeconds since the seconds.</dd>
  <dt>getTimeStampTag</dt>
    <dd>Get the array of timeStamp tag for each V3 channel.</dd>
  <dt>getAlarmSeverity</dt>
    <dd>Get the array of alarmseverity value for each V3 channel. </dd>
  <dt>getAlarmStatus</dt>
    <dd>Get the array of alarm status value for each V3 channel.</dd>
  <dt>getAlarmMessage</dt>
    <dd>Get the array of alarm messages for each V3 channel. This is just the
      string value of the V3 status.</dd>
  <dt>getDBRType</dt>
    <dd>This gets the array of native field types for each V3 channel. 
      <dl>
        <dt>DBF_STRING</dt>
        <dt>DBF_ENUM</dt>
          <dd>For both of these get and put will use DBR_STRING as the request
            type.</dd>
        <dt>DBF_CHAR</dt>
        <dt>DBF_INT</dt>
        <dt>DBF_LONG</dt>
          <dd>For all of these get and put will use DBR_LONG as the request
            type.</dd>
        <dt>DBF_FLOAT</dt>
        <dt>DBF_DOUBLE</dt>
          <dd>For both of these get and put will use DBR_DOUBLE as the request
            type.</dd>
      </dl>
    </dd>
  <dt>getIsConnected</dt>
    <dd>Get the array of connection state for each V3 channel. </dd>
  <dt>getChannelName</dt>
    <dd>Get the array of channel names for each V3 channel. </dd>
</dl>

<p>masarService/cpp/test/testGatherV3ScalarData/gatherV3ScalarDataExample.cpp
provides an example of how to use this class.</p>
<hr />

<h2 style="text-align: center" id="L458">Python Client</h2>
<hr />

<p>masarService/python/src/client has a set of python modules. Each implements
a python class.</p>

<h3 id="L464">channelRPC</h3>

<p>ChannelRPC is a python class that makes a channelRPC request. If is
implemented via a C extension module channelRPCPy which uses the EZChannelRPC.
Look at masarService/python/test/testchannelRPC.py for an example of how to use
this class.</p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from channelRPC import ChannelRPC as ChannelRPC
&gt;&gt;&gt; help(ChannelRPC)</pre>

<h3 id="L472">ntnameValue</h3>

<p>NTNameValue is a python class that wraps a C++ implementation of
NTNameValue. Once created it can be passed to other python methods that wrap
C++ code that expects to receive an PVStructure argument. For example
ChannelRPC.request expects to receive an argument that is a python object wraps
a pVStructure. For example testChannelRPC has the statements:</p>
<pre>from ntnameValue import NTNameValue as NTNameValue
function = "saveMasar"
args = { "data" : "pv_name,value,status,severity,timeStamp",
         "servicename" : "servicexxx",
         "configname" : "configxxx",
         "comment" : "This is a comment"
       }

ntnv = NTNameValue(function,args)
 ...
result =  channelRPC.request(ntnv.getNTNameValue(),False)</pre>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from ntnameValue import NTNameValue as NTNameValue
&gt;&gt;&gt; help(NTNameValue)</pre>

<h3 id="L482">nttable</h3>

<p>NTTable is a python class that wraps a C++ implementation of NTTable. It is
created by passing a python object that a wrapper for a C++ PVStructure that is
an NTTable. For example ChannelRPC.request returns such and object. Look at
testchannelRPC.py for an example of how this is used. </p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from nttable import NTTable as NTTable
&gt;&gt;&gt; help(NTTable)</pre>

<h3 id="L490">alarm</h3>

<p>Alarm is a python class is the python equivalent of PVStructure that
represents an alarm, i.e. is has a severity and a message.</p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from alarm import Alarm as Alarm
&gt;&gt;&gt; help(Alarm)</pre>

<h3 id="L498">timeStamp</h3>

<p>TimeStamp is a python class is the python equivalent of PVStructure that
represents a timeStamp, i.e. is has secondsPastEpoch and nanoSeconds within the
second. It has many methods for manipulating the timeStamp.</p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from timeStamp import TimeStamp as TimeStamp
&gt;&gt;&gt; help(TimeStamp)</pre>

<p>Look at masarService/python/test/testTimeStamp.py for examples of how to use
timeStamp.</p>
<hr />

<h2 style="text-align: center" id="L510">C++ Server</h2>
<hr />

<p>x</p>

<h3 id="L516">service</h3>

<p>For now this is only handles requests that are implemented by dslPY. Later
it will ???. For now it :</p>
<ul>
  <li>accepts the argument from request and checks to see if it is a
    NTNameValue. If it is not it returns NTTable with a alarm that reports
    failue.</li>
  <li>Checks to see that the NTNameValue has a function that is implemented by
    dslRDB. If it is not it returns NTTable with a alarm that reports
  failue.</li>
  <li>It calls dslRdb and returns the NTTable returned by dslRdb</li>
</ul>

<h3 id="L530">dsl.h - Data Source Layer</h3>

<p>This is the interface the Data Source Layer must implement. It will be
called by service. The class definition is:</p>
<pre>class DSL {
public:
    PVStructure::shared_pointer request(PVStructure pvArgument);
};</pre>

<p>Thus it takes a single argument which is a NTNameValue, performs whatever
database action is required, and returns a PVStructure that must be an
NTTable.</p>

<h3 id="L538">dslPy</h3>

<p>This is the C++ code that calls the python code that access the relational
database.</p>
<hr />

<h2 style="text-align: center" id="L544">Python Server</h2>
<hr />

<p>x</p>
<hr />

<h2 style="text-align: center" id="L552">Python support for Standard
Structures</h2>
<hr />

<p>Examples of Standard Structure are timeStamp and alarm. For each supported
structure:</p>
<ol>
  <li>The actual data is kept in a C++ object for the type.</li>
  <li>A python extension module wraps the C++ object.</li>
  <li>A python class is provided that calls the extension module.</li>
  <li>So that the C++ object can be passed to other C++ objects via python a
    python class method is provided that returns a python object that "wraps" a
    "void *" that is the address of the C++ object.</li>
</ol>

<p>Alarm is an example. The python class is
masarService/python/src/client/alarm.py. The extension modile is
masarService/cpp/src/python/alarmPy.cpp.</p>

<p>alarm.py has methods equivalent to what alarm.h provides. In particular it
has methods:</p>
<dl>
  <dt>__init__</dt>
    <dd>This is the constructor</dd>
  <dt>__del__</dt>
    <dd>This is the destructor</dd>
  <dt>__str__</dt>
    <dd>This returns a string showing the current alarm values.</dd>
  <dt>getAlarmPy</dt>
    <dd>This method returns a python object thet can be passed to another
      python object which calls a C++ wrapper that extracts the C++ object
      pointer so that it can pass it to other C++ code.</dd>
  <dt>getMessage</dt>
    <dd>Get the current alarm message.</dd>
  <dt>setMessage</dt>
    <dd>Set the current alarm message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the current alarm severity as a string.</dd>
  <dt>setSeverity</dt>
    <dd>Set the current alarm severity via a string.</dd>
  <dt>getStatus</dt>
    <dd>Get the current alarm status as a string.</dd>
  <dt>setStatus</dt>
    <dd>Set the current alarm status via a string.</dd>
  <dt>getSeverityChoices</dt>
    <dd>Get a tuple of the severity choices.</dd>
  <dt>getStatusChoices</dt>
    <dd>Get a tuple of the status choices.</dd>
</dl>

<p></p>

<p>Each of these has a corresponding function in alarmPy.cpp.</p>
<hr />

<h2 style="text-align: center" id="L642">Python support for Normative Types</h2>
<hr />

<p>This is similar to the support for standard structures with the following
differences:</p>
<ul>
  <li>The C++ extension module has a shared pointer to the PVStructure
    associated with the NT type.</li>
  <li>The PyObject that "wraps" a "void *" pointer wraps a
    "PVStructure::shared_pointer *".</li>
</ul>
<hr />

<h2 style="text-align: center" id="L657">Python support for pvAccess</h2>
<hr />

<p>At present there is only python suppport for making a channelRPC request.
Again there is a python class masarService/python/src/client/channelRPC.py
which makes calls to masarService/cpp/src/python/channelRPCPy.cpp. The C++
extension "wraps" ezchannelRPC.</p>
</body>
</html>
