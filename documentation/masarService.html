<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>EPICS masarService</title>
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/base.css" />
  <link rel="stylesheet" type="text/css"
  href="http://epics-pvdata.sourceforge.net/epicsv4.css" />
  <style type="text/css">
/*<![CDATA[*/
     .about { margin-left: 3em; margin-right: 3em; font-size: .83em}
     table { margin-left: auto; margin-right: auto }
     .diagram { text-align: center; margin: 2.5em 0 }
     body { margin-right: 10% }
/*]]>*/</style>
</head>

<body>

<div class="head">
<h1>EPICS masarService</h1>
<!-- Maturity: Working Draft or Request for Comments, or Recommendation, and date.  -->

<h2 class="nocount" id="L50">EPICS v4 Working Group, Working Draft,
12-Jan-2012</h2>
<dl>
  <dt>This version:</dt>
    <dd><a
      href="http://epics-pvdata.sourceforge.net/masarService_20111220.html">masarService_20120111.html</a></dd>
  <dt>Editors:</dt>
    <dd>Guobao Shen, BNL</dd>
    <dd>Marty Kraimer, BNL</dd>
</dl>
<hr />
</div>

<h2 class="nocount" id="L69">Abstract</h2>

<p>masarService is a service that creates, saves, and retrieves snapshots of
data from a set of V3 channels.</p>

<p>It is one of a set of related products:</p>
<dl>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/masarService/raw-file/tip/documentation/masarService.html">pvData</a></dt>
    <dd>pvData (Process Variable Daata) defines and implements an efficent way
      to store, access, and transmit memory resident structured data</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvAccessCPP/raw-file/tip/documentation/pvAccessCPP.html">pvAccess</a></dt>
    <dd>pvAccess is network support for transmitting pvData.</dd>
  <dt><a
  href="http://epics-pvdata.hg.sourceforge.net/hgweb/epics-pvdata/pvIOCCPP/raw-file/tip/documentation/pvIOCCPP.html">pvIOC</a></dt>
    <dd>A pvIOC is a network accessable smart real time database. The database
      consists of memory resident records. Each record has a name that is
      uniquie within the local area network and contains a top level pvData
      structure. Each field of a record can optionally have support code
      attached to it. The support is called when a request is made to process
      the record. The support code is what makes the record "smart". A pvAccess
      server is provided so that the records can be accesed via the network.
    </dd>
</dl>

<p>Each of the products has a Java and a C++ implementation.</p>

<p>The products are all part of the <a
href="http://epics-pvdata.sourceforge.net/">V4</a> implementation of <a
href="http://www.aps.anl.gov/epics/">Experimental Physics and Industrial
Control System.</a></p>

<h2 class="nocount" id="L103">Status of this Document</h2>

<p>This is the C++ and python implementation of masarService. It is currently
under development.</p>

<p>CONTENTS</p>

<div class="toc">
<ul>
  <li><a href="#L50">EPICS v4 Working Group, Working Draft, 12-Jan-2012</a></li>
  <li><a href="#L69">Abstract</a></li>
  <li><a href="#L103">Status of this Document</a></li>
  <li><a href="#L111">Preface</a></li>
  <li><a href="#L131">Introduction</a></li>
  <li><a href="#L139">Building</a></li>
  <li><a href="#L173">Testing</a>
    <ul>
      <li><a href="#L179">gatherV3DoubleExample</a></li>
      <li><a href="#L189">gatherV3DoubleTest</a></li>
      <li><a href="#L197">masarServiceRun</a></li>
      <li><a href="#L209">testezchannelRPC</a></li>
      <li><a href="#L217">testchannelRPC.py</a></li>
    </ul>
  </li>
  <li><a href="#L229">C++ Client</a>
    <ul>
      <li><a href="#L235">ezchannelRPC</a></li>
      <li><a href="#L291">gatherV3Double</a></li>
    </ul>
  </li>
  <li><a href="#L367">Python Client</a>
    <ul>
      <li><a href="#L373">channelRPC</a></li>
      <li><a href="#L381">ntnameValue</a></li>
      <li><a href="#L391">nttable</a></li>
      <li><a href="#L399">alarm</a></li>
      <li><a href="#L407">timeStamp</a></li>
    </ul>
  </li>
  <li><a href="#L419">C++ Server</a>
    <ul>
      <li><a href="#L425">service</a></li>
      <li><a href="#L439">dsl.h - Data Source Layer</a></li>
      <li><a href="#L447">dslPy</a></li>
    </ul>
  </li>
  <li><a href="#L453">Python Server</a></li>
  <li><a href="#L461">Python support for Standard Structures</a></li>
  <li><a href="#L547">Python support for Normative Types</a></li>
  <li><a href="#L562">Python support for pvAccess</a></li>
</ul>
</div>
<hr />

<h2 style="text-align: center" id="L111">Preface</h2>
<hr />

<p>This product is available via an <a
href="http://epics-pvdata.sourceforge.net/LICENSE.html">open source
license</a></p>

<p>This is the overview for masarService, which is a service that defines,
creates, and retrieves snapshots of data from a set of V3 channels.</p>

<p>An arbitrary number of snapshot definitions can be created and saved in a
relational database. I snapshot definition defines a set of V3 channels from
which to collect data.</p>

<p>For each shapshot definition an arbitrary set of snapshots can be obtained
and saved in the relational database.</p>

<p>A client can retrive any saved snapshot.</p>

<p>This service uses pvData/pvAccess for all communication between a client and
the masarSevice.</p>
<hr />

<h2 style="text-align: center" id="L131">Introduction</h2>
<hr />

<p>x</p>
<hr />

<h2 style="text-align: center" id="L139">Building</h2>
<hr />

<p>For now the only way to obtain the masarService is from the sourceforge
mercurial repository. For example:</p>
<pre>hg clone http://epics-pvdata.hg.sourceforge.net/hgroot/epics-pvdata/masarService</pre>

<p>or</p>
<pre>hg clone ssh://&lt;your-sourceforge-userid&gt;@epics-pvdata.hg.sourceforge.net/hgroot/epics-pvdata/masarSevice</pre>

<p>After cloning the masarService a RELEASE.local file for C++ must be created
and the masarService must be built.</p>
<pre>cd masarSevice/cpp/configure
create configure/RELEASE.local
make</pre>

<p>The RELEASE.local must define several variables. An example is:</p>
<pre>PYTHON=python2.7
PYTHON_BASE=/usr

REPBASE=/home/mrk/hg
PVDATA=${REPBASE}/pvDataCPP
PVACCESS=${REPBASE}/pvAccessCPP
PVIOC=${REPBASE}/pvIOCCPP
NT=${REPBASE}/alphaCPP/normativeTypes

EPICS_BASE=/home/install/epics/base</pre>

<p>Note that python, pvData, pvAccess, pvIOC, and normatives types must all be
installed and built in order to build the masaarService.</p>

<p>Once the masarService is build the tests described in the next section can
be run to check that everything has built properly.</p>

<p>The python code requires that that the extension modules have links to a
shared library. To create these links do the following:</p>
<pre>cd masarService/cpp/src/python
python generateSOLinks.py</pre>

<p>Also PYTHONPATH must have definitions similar to the following:</p>
<pre>export PYTHONPATH=/home/install/python2.7/lib/python2.7/site-packages/
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/cpp/src/python
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/python/src/server
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/python/src/client
export PYTHONPATH=$PYTHONPATH:/home/mrk/hg/masarService/python</pre>
<hr />

<h2 style="text-align: center" id="L173">Testing</h2>
<hr />

<p>masarService/python/test has some python tests. The following are C++
tests.</p>

<h3 id="L179">gatherV3DoubleExample</h3>

<p>This tests gets a set of V3 channels. This test requires the test V3
database of the gather service. It must be started before running this test.
For example:</p>
<pre>mrk&gt; pwd
/home/mrk/javaIOC/pvService/gather/caV3/iocBoot/iocAll
mrk&gt; ../../bin/linux-x86/example st.cmd </pre>

<p>Then in another window just execute:</p>
<pre>mrk&gt; pwd
/home/mrk/hg/masarService/cpp
mrk&gt; bin/linux-x86/gatherV3DoubleExample 
values: double[] value [1.49182,1.49182,1.49182,1.49182,1.49182,1.49182,1.49182,1.49182,1.49182,1.49182]
values: double[] value [1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212]
values: double[] value [1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212,1.82212]
values: double[] value [2.22554,2.22554,2.22554,2.22554,2.22554,2.22554,2.22554,2.22554,2.22554,2.22554]</pre>

<h3 id="L189">gatherV3DoubleTest</h3>

<p>This tests gets a large set of V3 channels. This test also requires the test
V3 database of the gather service. It must be started before running this
test.</p>

<p>This test prints nothing if it is successfull. To run just execute:</p>
<pre>mrk&gt; pwd
/home/mrk/hg/masarService/cpp
mrk&gt; bin/linux-x86/gatherV3DoubleExample </pre>

<h3 id="L197">masarServiceRun</h3>

<p>This is a dummy server. it just accepts a channelRPC request and always
returns a PVStructure that is an NTTable.</p>

<p>To start the server:</p>
<pre>cd masarService/cpp/bin/&lt;arch&gt;
 ./masarServiceRun</pre>

<p>To stop the server type "exit".</p>

<p>The server must be run in order to run the next two tests.</p>

<h3 id="L209">testezchannelRPC</h3>

<p>This is a C++ client that makes a channelRPC request to the dummy server.</p>

<p>To run this test:</p>
<pre>cd masarService/cpp/bin/&lt;arch&gt;
 ./testezchannelRPC</pre>

<h3 id="L217">testchannelRPC.py</h3>

<p>This is a python client program that makes a channelRPC request to the dummy
server.</p>

<p>To run this test:</p>
<pre>cd masarService/python/test
python testchannelRPC.py</pre>

<p></p>
<hr />

<h2 style="text-align: center" id="L229">C++ Client</h2>
<hr />

<p>This section describes two client facilities that will both be moved tp
EZPVA ( Easy PVAccess) when it exists. For now they are here because the
masarService needs them.</p>

<h3 id="L235">ezchannelRPC</h3>

<p>EZChannelRPC is class that provides an easy way to make a channelRPC
request. The client provides a PVStructure that is the argument for the
channelRPC request and receives a PVStructure that holds the result. The class
definition is:</p>
<pre>class EZChannelRPC {
public:
    EZChannelRPC(String channelName);
    EZChannelRPC(String channelName,PVStructure::shared_pointer pvRequest);
    void destroy();
    bool connect(double timeOut);
    void issueConnect();
    bool waitConnect(double timeOut);
    PVStructure::shared_pointer request(
        PVStructure::shared_pointer const &amp; pvArgument,bool lastRequest);
    void  issueRequest(
        PVStructure::shared_pointer const &amp; pvArgument,bool lastRequest);
    PVStructure::shared_pointer waitRequest();
    String getMessage();
};</pre>

<p>where</p>
<dl>
  <dt>EZChannelRPC</dt>
    <dd>The constructor. channelName is the name of the channelRPC server.
      pvRequest is a request structure to pass to the server. If pvRequest is
      not given a default structure will be created.</dd>
  <dt>destroy</dt>
    <dd>This will clean up all resources used by the channelRPC </dd>
  <dt>connect</dt>
    <dd>Connect to the server. The method blocks until the connection is made
      or a timeout occurs. It is the same as calling issueConnect and then
      waitConnect. returns (false,true) if (not connected, is connected). If
      false then connect must be reissued. </dd>
  <dt>issueConnect</dt>
    <dd>Issue a connect request and return immediately. waitConnect must be
      called to complete the request. </dd>
  <dt>waitConnect</dt>
    <dd>Wait for the connect request to complete. timeout is the timeout in
      seconds to wait. returns (false,true) If (not connected, is connected).
      If false then connect must be reissued. </dd>
  <dt>request</dt>
    <dd>Make a channelRPC request. pvArgument is the argument to pass to the
      server. If lastRequest is true an automatic destroy is made. returns the
      result. If the result is null then getMessage can be called to get the
      reason. </dd>
  <dt>issueRequest</dt>
    <dd>Issue a channelRPC request and return immediately. pvArgument is the
      argument to pass to the server. If lastRequest is true an automatic
      destroy is made. waitRequest must be called to complete the request. </dd>
  <dt>waitRequest</dt>
    <dd>Wait for the request to complete. returns the result. If the result is
      null then getMessage can be called to get the reason. </dd>
  <dt>getMessage</dt>
    <dd>Get the reason why a connect or request failed.</dd>
</dl>

<p>masarService/cpp/test/testezchannelRPC/testezchannelRPC.cpp provides an
example of how to use this class.</p>

<h3 id="L291">gatherV3Double</h3>

<p>Gather an array of V3 scalar double values. The complete set of data is
presented as an NTTable. The NTTable has the optional fields alarm and
timeStamp. The class definition is:</p>
<pre>class GatherV3Double {
public:
    GatherV3Double(String channelNames[],int numberChannels);
    bool connect(double timeOut);
    void disconnect();
    bool get();
    String getMessage();
    PVStructure::shared_pointer getNTTable();
    PVDoubleArray *getValue();
    PVDoubleArray *getDeltaTime();
    PVIntArray *getSeverity();
    PVBooleanArray *getIsConnected();
    PVStringArray  *getChannelName();
};</pre>

<p>where</p>
<dl>
  <dt>GatherV3Double</dt>
    <dd>The constructor. channelNames is the array of channelNames to gather.
      numberChannels is the number of channels to gather. </dd>
  <dt>connect</dt>
    <dd>Connect to V3 channels. This call blocks until all channels are
      connected or until timeout. timeout is the number of seconds to wait for
      connections. The return value is true if all channels are connected and
      false otherwise. If false then all channels are cleared and connect must
      be reissued. </dd>
  <dt>disconnect</dt>
    <dd>Disconnect from the V3 channels.</dd>
  <dt>get</dt>
    <dd>Get the current values of the V3 channels.</dd>
    <dd><b>NOTE:</b> get MUST be called by the same thread that calls
    connect.</dd>
    <dd>The return value is true if all gets were successful. If the return
      value is false then getMessage can be called to get the reason. If any
      channel is disconnected false is returned. </dd>
  <dt>getMessage</dt>
    <dd>Get the reason why a connect or get failed.</dd>
  <dt>getNTTable</dt>
    <dd>The data is saved as an NTTable with alarm and timeStamp. Get it.</dd>
  <dt>getValue</dt>
    <dd>Get the array of values for each V3 channel.</dd>
  <dt>getDeltaTime</dt>
    <dd>Get the array of delta times for each V3 channel. This is the time
      difference relative to the NTTable timeStamp. </dd>
  <dt>getSeverity</dt>
    <dd>Get the array of severity value for each V3 channel. </dd>
  <dt>getIsConnected</dt>
    <dd>Get the array of connection state for each V3 channel. </dd>
  <dt>getChannelName</dt>
    <dd>Get the array of channel names for each V3 channel. </dd>
</dl>

<p>masarService/cpp/test/testGatherV3Double/gatherV3DoubleExample.cpp provides
an example of how to use this class.</p>
<hr />

<h2 style="text-align: center" id="L367">Python Client</h2>
<hr />

<p>masarService/python/src/client has a set of python modules. Each implements
a python class.</p>

<h3 id="L373">channelRPC</h3>

<p>ChannelRPC is a python class that makes a channelRPC request. If is
implemented via a C extension module channelRPCPy which uses the EZChannelRPC.
Look at masarService/python/test/testchannelRPC.py for an example of how to use
this class.</p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from channelRPC import ChannelRPC as ChannelRPC
&gt;&gt;&gt; help(ChannelRPC)</pre>

<h3 id="L381">ntnameValue</h3>

<p>NTNameValue is a python class that wraps a C++ implementation of
NTNameValue. Once created it can be passed to other python methods that wrap
C++ code that expects to receive an PVStructure argument. For example
ChannelRPC.request expects to receive an argument that is a python object wraps
a pVStructure. For example testChannelRPC has the statements:</p>
<pre>from ntnameValue import NTNameValue as NTNameValue
function = "saveMasar"
args = { "data" : "pv_name,value,status,severity,timeStamp",
         "servicename" : "servicexxx",
         "configname" : "configxxx",
         "comment" : "This is a comment"
       }

ntnv = NTNameValue(function,args)
 ...
result =  channelRPC.request(ntnv.getNTNameValue(),False)</pre>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from ntnameValue import NTNameValue as NTNameValue
&gt;&gt;&gt; help(NTNameValue)</pre>

<h3 id="L391">nttable</h3>

<p>NTTable is a python class that wraps a C++ implementation of NTTable. It is
created by passing a python object that a wrapper for a C++ PVStructure that is
an NTTable. For example ChannelRPC.request returns such and object. Look at
testchannelRPC.py for an example of how this is used. </p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from nttable import NTTable as NTTable
&gt;&gt;&gt; help(NTTable)</pre>

<h3 id="L399">alarm</h3>

<p>Alarm is a python class is the python equivalent of PVStructure that
represents an alarm, i.e. is has a severity and a message.</p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from alarm import Alarm as Alarm
&gt;&gt;&gt; help(Alarm)</pre>

<h3 id="L407">timeStamp</h3>

<p>TimeStamp is a python class is the python equivalent of PVStructure that
represents a timeStamp, i.e. is has secondsPastEpoch and nanoSeconds within the
second. It has many methods for manipulating the timeStamp.</p>

<p>To see the methods:</p>
<pre>mrk&gt; python
Python 2.7 (r27:82500, Sep 16 2010, 18:03:06) 
[GCC 4.5.1 20100907 (Red Hat 4.5.1-3)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; from timeStamp import TimeStamp as TimeStamp
&gt;&gt;&gt; help(TimeStamp)</pre>

<p>Look at masarService/python/test/testTimeStamp.py for examples of how to use
timeStamp.</p>
<hr />

<h2 style="text-align: center" id="L419">C++ Server</h2>
<hr />

<p>x</p>

<h3 id="L425">service</h3>

<p>For now this is only handles requests that are implemented by dslPY. Later
it will ???. For now it :</p>
<ul>
  <li>accepts the argument from request and checks to see if it is a
    NTNameValue. If it is not it returns NTTable with a alarm that reports
    failue.</li>
  <li>Checks to see that the NTNameValue has a function that is implemented by
    dslRDB. If it is not it returns NTTable with a alarm that reports
  failue.</li>
  <li>It calls dslRdb and returns the NTTable returned by dslRdb</li>
</ul>

<h3 id="L439">dsl.h - Data Source Layer</h3>

<p>This is the interface the Data Source Layer must implement. It will be
called by service. The class definition is:</p>
<pre>class DSL {
public:
    PVStructure::shared_pointer request(PVStructure pvArgument);
};</pre>

<p>Thus it takes a single argument which is a NTNameValue, performs whatever
database action is required, and returns a PVStructure that must be an
NTTable.</p>

<h3 id="L447">dslPy</h3>

<p>This is the C++ code that calls the python code that access the relational
database.</p>
<hr />

<h2 style="text-align: center" id="L453">Python Server</h2>
<hr />

<p>x</p>
<hr />

<h2 style="text-align: center" id="L461">Python support for Standard
Structures</h2>
<hr />

<p>Examples of Standard Structure are timeStamp and alarm. For each supported
structure:</p>
<ol>
  <li>The actual data is kept in a C++ object for the type.</li>
  <li>A python extension module wraps the C++ object.</li>
  <li>A python class is provided that calls the extension module.</li>
  <li>So that the C++ object can be passed to other C++ objects via python a
    python class method is provided that returns a python object that "wraps" a
    "void *" that is the address of the C++ object.</li>
</ol>

<p>Alarm is an example. The python class is
masarService/python/src/client/alarm.py. The extension modile is
masarService/cpp/src/python/alarmPy.cpp.</p>

<p>alarm.py has methods equivalent to what alarm.h provides. In particular it
has methods:</p>
<dl>
  <dt>__init__</dt>
    <dd>This is the constructor</dd>
  <dt>__del__</dt>
    <dd>This is the destructor</dd>
  <dt>__str__</dt>
    <dd>This returns a string showing the current alarm values.</dd>
  <dt>getAlarmPy</dt>
    <dd>This method returns a python object thet can be passed to another
      python object which calls a C++ wrapper that extracts the C++ object
      pointer so that it can pass it to other C++ code.</dd>
  <dt>getMessage</dt>
    <dd>Get the current alarm message.</dd>
  <dt>setMessage</dt>
    <dd>Set the current alarm message.</dd>
  <dt>getSeverity</dt>
    <dd>Get the current alarm severity as a string.</dd>
  <dt>setSeverity</dt>
    <dd>Set the current alarm severity via a string.</dd>
  <dt>getStatus</dt>
    <dd>Get the current alarm status as a string.</dd>
  <dt>setStatus</dt>
    <dd>Set the current alarm status via a string.</dd>
  <dt>getSeverityChoices</dt>
    <dd>Get a tuple of the severity choices.</dd>
  <dt>getStatusChoices</dt>
    <dd>Get a tuple of the status choices.</dd>
</dl>

<p></p>

<p>Each of these has a corresponding function in alarmPy.cpp.</p>
<hr />

<h2 style="text-align: center" id="L547">Python support for Normative Types</h2>
<hr />

<p>This is similar to the support for standard structures with the following
differences:</p>
<ul>
  <li>The C++ extension module has a shared pointer to the PVStructure
    associated with the NT type.</li>
  <li>The PyObject that "wraps" a "void *" pointer wraps a
    "PVStructure::shared_pointer *".</li>
</ul>
<hr />

<h2 style="text-align: center" id="L562">Python support for pvAccess</h2>
<hr />

<p>At present there is only python suppport for making a channelRPC request.
Again there is a python class masarService/python/src/client/channelRPC.py
which makes calls to masarService/cpp/src/python/channelRPCPy.cpp. The C++
extension "wraps" ezchannelRPC.</p>
</body>
</html>
